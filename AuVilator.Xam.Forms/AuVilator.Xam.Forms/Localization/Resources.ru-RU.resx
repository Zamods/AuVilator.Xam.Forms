<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AuVilator_Welcome" xml:space="preserve">
    <value>Добро пожаловать в AuVilator.</value>
  </data>
  <data name="BinSizeSelectedLabelText" xml:space="preserve">
    <value>Образцы</value>
  </data>
  <data name="BinSizeSelectionInformationText" xml:space="preserve">
    <value>Выберите размер корзины, который вы предпочитаете AuVilator для обработки медиафайла.
Обратите внимание: чем больше размер корзины, тем больше вычислений будет выполнять AuVilator, что замедлит обработку.
Меньший размер бункера позволяет очистить больше тишины по сравнению с большим размером, тогда как больший размер может привести к потере сигналов без тишины.</value>
  </data>
  <data name="BinSizeSelectionTitleText" xml:space="preserve">
    <value>Выберите размер ячейки для анализа сигналов</value>
  </data>
  <data name="EndAmpPosInformationText" xml:space="preserve">
    <value>Выберите значение амплитуды для определения немого сигнала.
Обратите внимание, что AuVilator использует это значение для поиска конечной точки бункера немого сигнала.
Учтите, что размер бина напрямую влияет на эти значения.</value>
  </data>
  <data name="EndAmpPosSelectionTitleText" xml:space="preserve">
    <value>Выберите конечную амплитуду для сигнала</value>
  </data>
  <data name="FileSelectionButtonText" xml:space="preserve">
    <value>Выберите аудиофайл</value>
  </data>
  <data name="FileSelectionTitleText" xml:space="preserve">
    <value>Выберите аудиофайл, чтобы отключить тишину</value>
  </data>
  <data name="Gen_Error_Stack" xml:space="preserve">
    <value>Стек ошибок:</value>
  </data>
  <data name="InformationCloseButtonText" xml:space="preserve">
    <value>Закрыть</value>
  </data>
  <data name="InformationTitleText" xml:space="preserve">
    <value>Информация</value>
  </data>
  <data name="NoFileSelected" xml:space="preserve">
    <value>Файл еще не выбран!</value>
  </data>
  <data name="RunSilencerButtonText" xml:space="preserve">
    <value>Запустить глушитель</value>
  </data>
  <data name="SelectFileInformationText" xml:space="preserve">
    <value>Выберите любой аудио- или видеофайл для обработки.
Однако AuVilator будет извлекать только аудиосигналы независимо от формата файла и возвращать результаты в файле wav.</value>
  </data>
  <data name="Settings_V_Language_Change_Btn" xml:space="preserve">
    <value>изменение</value>
  </data>
  <data name="Settings_V_Language_TB" xml:space="preserve">
    <value>Язык</value>
  </data>
  <data name="Settings_V_Main_Title" xml:space="preserve">
    <value>Настройки</value>
  </data>
  <data name="SilencerVM_CFF_EX_Caption" xml:space="preserve">
    <value>Неверный формат файла!</value>
  </data>
  <data name="SilencerVM_CFF_EX_Text_1" xml:space="preserve">
    <value>Выбранный файл</value>
  </data>
  <data name="SilencerVM_CFF_EX_Text_2" xml:space="preserve">
    <value>не является форматом .wav.</value>
  </data>
  <data name="SilencerVM_CFF_EX_Text_3" xml:space="preserve">
    <value>Пожалуйста, выберите файл еще раз.</value>
  </data>
  <data name="SilencerVM_LF_EX_Caption" xml:space="preserve">
    <value>Ошибка при загрузке файла!</value>
  </data>
  <data name="SilencerVM_LF_EX_Text" xml:space="preserve">
    <value>AuVilator не удалось загрузить выбранный файл.</value>
  </data>
  <data name="SilencerVM_LF_MB_No_Selected_Caption" xml:space="preserve">
    <value>Файл не выбран!</value>
  </data>
  <data name="SilencerVM_LF_MB_No_Selected_Text" xml:space="preserve">
    <value>No file selected!</value>
  </data>
  <data name="SilencerVM_LF_Select_Picker_Filter_All" xml:space="preserve">
    <value>Все файлы</value>
  </data>
  <data name="SilencerVM_LF_Select_Picker_Filter_Audio" xml:space="preserve">
    <value>Аудио файлы</value>
  </data>
  <data name="SilencerVM_LF_Select_Wav_Title" xml:space="preserve">
    <value>Выберите файл .wav для обработки.</value>
  </data>
  <data name="SilencerVM_SF_EX_Caption" xml:space="preserve">
    <value>Ошибка при получении пути или имени для сохранения файла!</value>
  </data>
  <data name="SilencerVM_SF_EX_Text" xml:space="preserve">
    <value>AuVilator не удалось получить путь или имя для сохранения.</value>
  </data>
  <data name="SilencerVM_SF_MB_No_Selected_Text" xml:space="preserve">
    <value>Путь к файлу или имя не указаны!</value>
  </data>
  <data name="SilencerVM_SF_Save_Picker_Title" xml:space="preserve">
    <value>Сохранить как</value>
  </data>
  <data name="SilencerVM_STA_EX_Caption" xml:space="preserve">
    <value>Ошибка процесса!</value>
  </data>
  <data name="SilencerVM_STA_EX_Text" xml:space="preserve">
    <value>Что-то пошло не так при обработке данного файла.</value>
  </data>
  <data name="SilencerVM_STA_MB_Caption" xml:space="preserve">
    <value>Процесс завершен!</value>
  </data>
  <data name="SilencerVM_STA_MB_Text" xml:space="preserve">
    <value>Ваш аудиофайл успешно обработан!</value>
  </data>
  <data name="Silencer_V_Cancel_Btn" xml:space="preserve">
    <value>Отмена</value>
  </data>
  <data name="StartAmpPosInformationText" xml:space="preserve">
    <value>Выберите значение амплитуды для определения немого сигнала.
Обратите внимание, что AuVilator использует это значение для поиска начальной точки бункера немолчного сигнала.
Учтите, что размер бина напрямую влияет на эти значения.</value>
  </data>
  <data name="StartAmpPosSelectionTitleText" xml:space="preserve">
    <value>Выберите начальную амплитуду сигнала</value>
  </data>
  <data name="Button_OK" xml:space="preserve">
    <value>Отмена</value>
  </data>
  <data name="BinSizePickerText" xml:space="preserve">
    <value>Выберите размер корзины</value>
  </data>
  <data name="Settings_V_Language_Change_Picker_Title" xml:space="preserve">
    <value>Выберите язык</value>
  </data>
</root>